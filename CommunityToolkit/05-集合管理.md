# CommunityToolkit.Mvvm 集合管理详解

## 概述

在MVVM架构中，集合管理是数据展示的核心功能。CommunityToolkit.Mvvm提供了强大的集合管理工具，特别是 `ObservableGroupedCollection<TKey, TValue>`，为复杂数据展示场景提供了优雅的解决方案。

## 核心组件

### 1. ObservableGroupedCollection 详解

#### 基本构造

```csharp
using CommunityToolkit.Mvvm.Collections;

// 创建基础分组集合
var groupedCollection = new ObservableGroupedCollection<string, Contact>();

// 使用工厂方法创建
var grouped = new ObservableGroupedCollection<string, Contact>(
    contacts.GroupBy(c => c.GroupName));

// 键比较器自定义
var custom = new ObservableGroupedCollection<string, Contact>(
    contacts.GroupBy(c => c.GroupName), 
    StringComparer.OrdinalIgnoreCase);
```

#### 联系人分组示例

```csharp
public partial class ContactsListViewModel : ObservableObject
{
    private readonly IContactsService _contactsService;
    
    public ContactsListViewModel(IContactsService contactsService)
    {
        _contactsService = contactsService;
        LoadContacts();
    }

    // 分组联系人集合
    public ObservableGroupedCollection<string, Contact> Contacts { get; private set; } = new();

    [RelayCommand]
    private async Task LoadContactsAsync()
    {
        // 模拟获取联系人数据
        var contacts = await _contactsService.GetContactsAsync(50);
        
        // 按姓氏首字母分组
        Contacts = new ObservableGroupedCollection<string, Contact>(
            contacts
                .GroupBy(c => GetLastNameFirstLetter(c.Name))
                .OrderBy(g => g.Key));
        
        OnPropertyChanged(nameof(Contacts));
    }

    private string GetLastNameFirstLetter(string fullName)
    {
        if (string.IsNullOrWhiteSpace(fullName)) return "#";
        
        // 提取姓氏首字母
        var lastName = fullName.Trim().Split(' ').LastOrDefault() ?? fullName;
        return lastName.Length > 0 ? lastName[0].ToString().ToUpper() : "#";
    }
}
```

### 2. 动态数据操作

#### 添加项目到特定分组

```csharp
[ObservableProperty]
private ObservableGroupedCollection<string, Contact> contacts;

[RelayCommand]
private void AddContact()
{
    var newContact = new Contact
    {
        Name = "Alice Johnson",
        Email = "alice@example.com",
        Phone = "+1-555-1234"
    };
    
    var groupKey = GetLastNameFirstLetter(newContact.Name);
    
    Contacts.InsertItem(
        key: groupKey,
        keyComparer: StringComparer.OrdinalIgnoreCase,
        item: newContact,
        itemComparer: Comparer<Contact>.Create((a, b) => 
            string.Compare(a.Name, b.Name, StringComparison.Ordinal)));
}
```

#### 批量操作

```csharp
public partial class ProductCatalogViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, Product> products = new();

    [RelayCommand]
    private async Task LoadProductsAsync()
    {
        var products = await _productService.GetProductsAsync(100);
        
        // 高效批量加载
        Products.Clear();
        
        foreach (var group in products.GroupBy(p => p.Category))
        {
            foreach (var product in group.OrderBy(p => p.Name))
            {
                Products.TryInsertItem(
                    group.Key,
                    product,
                    Comparer<Product>.Create((a, b) => a.Name.CompareTo(b.Name)));
            }
        }
    }

    [RelayCommand]
    private void AddProduct(Product product)
    {
        // 安全的添加操作（避免重复键和排序问题）
        var key = product.Category;
        Products.TryInsertItem(
            key: key,
            item: product,
            Comparer<Product>.Create((a, b) => a.Name.CompareTo(b.Name)));
    }

    [RelayCommand]
    private void RemoveProduct(Product product)
    {
        // 从分组中删除
        var group = Products.GroupedItems.FirstOrDefault(g => g.Key == product.Category);
        if (group != null)
        {
            // 找到并删除项目
            foreach (var item in group)
            {
                if (item.Id == product.Id)
                {
                    group.Remove(item);
                    break;
                }
            }
            
            // 如果分组为空，删除整个分组
            if (!group.Any())
            {
                Products.Remove(group);
            }
        }
    }
}
```

### 3. 复杂数据结构处理

#### 多维度分组

```csharp
public partial class SalesDataViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, SalesRecord> salesByRegion = new();

    [ObservableProperty]
    private ObservableGroupedCollection<int, SalesRecord> salesByMonth = new();

    [ObservableProperty]  
    private ObservableGroupedCollection<(string Region, int Month), SalesRecord> salesByRegionAndMonth = new();

    [RelayCommand]
    private async Task LoadSalesDataAsync()
    {
        var sales = await _salesService.GetSalesDataAsync();

        // 按地区分组
        SalesByRegion = new ObservableGroupedCollection<string, SalesRecord>(
            sales.GroupBy(s => s.Region));

        // 按月份分组
        SalesByMonth = new ObservableGroupedCollection<int, SalesRecord>(
            sales.GroupBy(s => s.SaleDate.Month));

        // 地区+月份组合分组
        SalesByRegionAndMonth = new ObservableGroupedCollection<(string, int), SalesRecord>(
            sales.GroupBy(s => (s.Region, s.SaleDate.Month)));
    }

    public decimal GetTotalForRegion(string region)
    {
        return SalesByRegion[region]?.Sum(s => s.Amount) ?? 0m;
    }

    public record SalesRecord
    {
        public string Region { get; init; } = string.Empty;
        public DateTime SaleDate { get; init; }
        public decimal Amount { get; init; }
        public string Product { get; init; } = string.Empty;
    }
}
```

#### 嵌套分组集合

```csharp
public partial class FileSystemViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, FileSystemItem> files = new();

    [ObservableProperty]
    private ObservableCollection<FileGroup> fileGroups = new();

    public class FileGroup : ObservableObject
    {
        [ObservableProperty]
        private string name = string.Empty;
        
        [ObservableProperty]
        private ObservableCollection<FileGroup>? subGroups;
        
        [ObservableProperty]
        private ObservableCollection<FileSystemItem> files = new();
    }

    public class FileSystemItem : ObservableObject
    {
        [ObservableProperty]
        private string name = string.Empty;
        
        [ObservableProperty]
        private long size;
        
        [ObservableProperty]
        private DateTime modifiedDate;
        
        [ObservableProperty]
        private string extension = string.Empty;
    }

    [RelayCommand]
    private void LoadFileSystemAsync()
    {
        // 加载文件系统结构
        var rootItems = GetFileSystemItems("C:\\");
        
        // 创建树形分组结构
        var tree = BuildFileTree(rootItems);
        Files = tree;
    }

    private ObservableGroupedCollection<string, FileSystemItem> BuildFileTree(
        IEnumerable<FileSystemItem> items)
    {
        return new ObservableGroupedCollection<string, FileSystemItem>(
            items.GroupBy(item => item.Extension)
                .OrderBy(g => g.Key));
    }
}
```

### 4. 高级集合操作

#### 动态筛选和排序

```csharp
public partial class FilteredCollectionViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, Product> products = new();

    [ObservableProperty]
    private string searchQuery = string.Empty;

    [ObservableProperty]
    private ProductCategory selectedCategory = ProductCategory.All;

    partial void OnSearchQueryChanged(string value)
    {
        UpdateFilteredProducts();
    }

    partial void OnSelectedCategoryChanged(ProductCategory value)
    {
        UpdateFilteredProducts();
    }

    private void UpdateFilteredProducts()
    {
        var filtered = GetOriginalProducts()
            .Where(p => FilterProduct(p));

        Products = new ObservableGroupedCollection<string, Product>(
            filtered.GroupBy(p => p.Category)
                    .OrderBy(g => g.Key));
    }

    private bool FilterProduct(Product product)
    {
        if (!string.IsNullOrWhiteSpace(SearchQuery))
        {
            return product.Name.Contains(SearchQuery, StringComparison.OrdinalIgnoreCase);
        }

        if (SelectedCategory != ProductCategory.All)
        {
            return product.Category == SelectedCategory.ToString();
        }

        return true;
    }
}
```

#### 分页和虚拟化

```csharp
public partial class PagedCollectionViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<DateTime, DataItem> paginatedData = new();

    [ObservableProperty]
    private int currentPage = 1;

    [ObservableProperty]
    private int itemsPerPage = 20;

    [ObservableProperty]
    private int totalItems = 0;

    [RelayCommand]
    private async Task LoadNextPageAsync()
    {
        var startIndex = (CurrentPage - 1) * ItemsPerPage;
        var endIndex = Math.Min(startIndex + ItemsPerPage, TotalItems);

        var newPageData = await _dataService.GetPagedDataAsync(startIndex, endIndex);

        // 增量添加数据
        foreach (var group in newPageData.GroupBy(item => item.Date.Date))
        {
            foreach (var item in group.OrderBy(i => i.Id))
            {
                PaginatedData.TryInsertItem(
                    group.Key,
                    item,
                    Comparer<DataItem>.Create((a, b) => a.Id.CompareTo(b.Id)));
            }
        }

        CurrentPage++;
    }

    [RelayCommand]
    private void ResetPagination()
    {
        PaginatedData.Clear();
        CurrentPage = 1;
    }

    public bool CanGoToNextPage => CurrentPage * ItemsPerPage < TotalItems;
}
```

### 5. 性能优化

#### 大批量数据处理

```csharp
public partial class LargeDataViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, DataItem> largeDataset = new();

    [ObservableProperty]
    private bool isLoading = false;

    [RelayCommand]
    private async Task LoadLargeDatasetAsync()
    {
        IsLoading = true;
        
        try
        {
            // 批量加载，减少UI更新次数
            LargeDataSet.SuspendNotifications();
            LargeDataSet.Clear();

            var totalItems = 100000;
            var itemsPerBatch = 1000;
            var batches = totalItems / itemsPerBatch;

            for (int batch = 0; batch < batches; batch++)
            {
                var items = await _dataService.GetDataBatchAsync(
                    batch * itemsPerBatch, 
                    itemsPerBatch);

                await Task.Run(() =>
                {
                    foreach (var item in items)
                    {
                        var key = item.GetGroupingKey();
                        LargeDataSet.TryInsertItem(
                            key,
                            item,
                            Comparer<DataItem>.Create((a, b) => a.Id.CompareTo(b.Id)));
                    }
                });

                // 每批次完成后允许UI少量更新
                await Task.Delay(10);
            }
        }
        finally
        {
            LargeDataSet.ResumeNotifications();
            IsLoading = false;
        }
    }
}
```

#### 延迟加载和虚拟滚动

```csharp
public partial class LazyCollectionViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<object, object> visibleItems = new();

    [ObservableProperty]
    private int visibleStartIndex = 0;

    [ObservableProperty]
    private int visibleCount = 100;

    [RelayCommand]
    private async Task ScrollToIndexAsync(int targetIndex)
    {
        if (targetIndex < 0 || targetIndex >= TotalItems)
            return;

        var scrollDirection = targetIndex > VisibleStartIndex ? 1 : -1;
        var step = Math.Abs(targetIndex - VisibleStartIndex);

        // 增量加载
        for (int i = 0; i <= step; i++)
        {
            var currentIndex = VisibleStartIndex + (scrollDirection * i);
            if (currentIndex >= 0 && currentIndex < TotalItems)
            {
                var item = await _dataService.GetItemAsync(currentIndex);
                var key = item.GetGroupingKey();
                VisibleItems.TryInsertItem(key, item);
                
                // 移除超出范围的旧项目
                if (i > VisibleCount)
                {
                    var oldestIndex = VisibleStartIndex + 
                        (scrollDirection * (i - VisibleCount));
                    if (oldestIndex >= 0)
                    {
                        var oldItem = await _dataService.GetItemAsync(oldestIndex);
                        VisibleItems.TryRemoveItem(oldItem.Key, oldItem.Id);
                    }
                }
            }
        }

        VisibleStartIndex = targetIndex;
    }
}
```

## 6. 分组集合的UI集成

### 6.1 MAUI中的使用

```xaml
<ListView ItemsSource="{Binding Contacts}"
          HasUnevenRows="True"
          IsGroupingEnabled="True"
          GroupDisplayBinding="{Binding Key}">
    <ListView.GroupHeaderTemplate>
        <DataTemplate>
            <ViewCell>
                <Label Text="{Binding Key}" 
                       FontAttributes="Bold"
                       BackgroundColor="#F0F0F0"
                       Padding="10,5"/>
            </ViewCell>
        </DataTemplate>
    </ListView.GroupHeaderTemplate>
    
    <ListView.ItemTemplate>
        <DataTemplate>
            <ViewCell>
                <Grid Padding="10,5">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                    </Grid.ColumnDefinitions>
                    
                    <Image Grid.Column="0" 
                           Source="{Binding Picture.Url}"
                           WidthRequest="40" 
                           HeightRequest="40"/>
                    
                    <VerticalStackLayout Grid.Column="1">
                        <Label Text="{Binding Name}" FontSize="16"/>
                        <Label Text="{Binding Email}" 
                               FontSize="12" 
                               TextColor="Gray"/>
                    </VerticalStackLayout>
                </Grid>
            </ViewCell>
        </DataTemplate>
    </ListView.ItemTemplate>
</ListView>
```

### 6.2 WPF中的使用

```xaml
<GroupStyle>
    <GroupStyle.HeaderTemplate>
        <DataTemplate>
            <Border Background="LightGray" CornerRadius="2">
                <TextBlock Text="{Binding Key}" 
                           FontWeight="Bold" 
                           Padding="5"/>
            </Border>
        </DataTemplate>
    </GroupStyle.HeaderTemplate>
</GroupStyle>
```

### 6.3 数据绑定的高级用法

```csharp
// 支持复杂绑定的分组模型
public partial class CollectionViewModel : ObservableObject
{
    [ObservableProperty]
    private ObservableGroupedCollection<GroupHeader, CollectionItem> items = new();

    [ObservableProperty]
    private GroupHeader? selectedGroup;

    [ObservableProperty]
    private CollectionItem? selectedItem;

    partial void OnSelectedGroupChanged(GroupHeader? value)
    {
        if (value != null)
        {
            SelectedItem = Items[value]?.FirstOrDefault();
        }
    }
}

public class GroupHeader : ObservableObject
{
    [ObservableProperty]
    private string title = string.Empty;
    
    [ObservableProperty]
    private int count;
    
    [ObservableProperty]
    private bool isExpanded = true;
}

public class CollectionItem : ObservableObject
{
    [ObservableProperty]
    private string id = string.Empty;
    
    [ObservableProperty]
    private string displayName = string.Empty;
    
    [ObservableProperty]
    private bool isSelected;
}
```

## 7. 性能监控和调试

### 7.1 性能监控

```csharp
public class CollectionPerformanceMonitor
{
    public async Task MonitorCollectionOperationsAsync(
        ObservableGroupedCollection<string, object> collection)
    {
        var stopwatch = new Stopwatch();
        
        collection.CollectionChanged += (s, e) =>
        {
            Console.WriteLine($"Collection changed: {e.Action}, Count: {collection.Count}");
        };

        stopwatch.Start();
        
        // 监测各种操作
        for (int i = 0; i < 1000; i++)
        {
            await Task.Yield();
            
            var start = stopwatch.ElapsedMilliseconds;
            collection.TryInsertItem("Group", new object());
            var elapsed = stopwatch.ElapsedMilliseconds - start;
            
            await Task.Delay(elapsed < 1 ? 1000 : 0);
        }
    }
}
```

### 7.2 内存管理

```csharp
public partial class ManagedCollectionViewModel : ObservableObject, IDisposable
{
    [ObservableProperty]
    private ObservableGroupedCollection<string, IDisposable> managedItems = new();

    public void Dispose()
    {
        foreach (var item in ManagedItems.SelectMany(g => g))
        {
            if (item is IDisposable disposable)
            {
                disposable.Dispose();
            }
        }
        
        ManagedItems.Clear();
        ManagedItems.Dispose();
    }
}
```

## 总结

这套集合管理解决方案为企业级应用提供了完整的支持，包括：
- 高性能的分组数据展示
- 动态数据更新和处理
- 大数据集的高效管理
- 与不同UI框架的无缝集成
- 内存友好的数据管理