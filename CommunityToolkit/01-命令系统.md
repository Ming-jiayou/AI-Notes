# CommunityToolkit.Mvvm 命令系统详解

## 概述

命令系统是MVVM模式的核心组件之一，CommunityToolkit.Mvvm提供了强大的命令实现，支持同步和异步操作，执行状态跟踪等高级功能。

## 核心组成

### 1. 基础命令接口

```csharp
// System.Windows.Input 命名空间提供的基础接口
public interface ICommand
{
    bool CanExecute(object parameter);
    void Execute(object parameter);
    event EventHandler CanExecuteChanged;
}
```

### 2. CommunityToolkit.Mvvm 提供的命令类

- **RelayCommand** - 基础同步命令
- **RelayCommand<T>** - 带参数的同步命令
- **AsyncRelayCommand** - 异步命令
- **AsyncRelayCommand<T>** - 带参数的异步命令

## 详细实现

### 同步命令 (RelayCommand)

#### 基本使用

```csharp
public class RelayCommandPageViewModel : ObservableObject
{
    public RelayCommandPageViewModel()
    {
        IncrementCounterCommand = new RelayCommand(IncrementCounter);
    }

    public ICommand IncrementCounterCommand { get; }

    private int counter;
    public int Counter
    {
        get => counter;
        private set => SetProperty(ref counter, value);
    }

    private void IncrementCounter() => Counter++;
}
```

#### 支持CanExecute的命令

```csharp
public class DemoViewModel : ObservableObject
{
    private bool isEnabled = true;
    
    public DemoViewModel()
    {
        SaveCommand = new RelayCommand(
            execute: () => SaveData(),
            canExecute: () => isEnabled && HasChanges);
    }

    public ICommand SaveCommand { get; }

    private void SaveData()
    {
        // 保存数据的逻辑
    }
}
```

### 异步命令 (AsyncRelayCommand)

#### 基本使用

```csharp
public class AsyncRelayCommandPageViewModel : ObservableObject
{
    public AsyncRelayCommandPageViewModel()
    {
        DownloadTextCommand = new AsyncRelayCommand(DownloadTextAsync);
    }

    public IAsyncRelayCommand DownloadTextCommand { get; }

    private async Task<string> DownloadTextAsync()
    {
        await Task.Delay(3000); // 模拟网络请求
        return "Hello world!";
    }
}
```

#### 执行状态跟踪

异步命令提供了丰富的执行状态属性：

- **IsRunning** - 命令是否正在执行
- **IsCanceled** - 命令是否被取消
- **IsFaulted** - 命令是否失败
- **ExecutionTask** - 执行的Task对象
- **ExecutionTask<T>** - 执行的Task<T>对象

#### XAML中的绑定

```xml
<Button Text="下载"
        Command="{Binding DownloadTextCommand}" />
<ActivityIndicator IsRunning="{Binding DownloadTextCommand.IsRunning}"
                   IsVisible="{Binding DownloadTextCommand.IsRunning}" />
<Label Text="{Binding DownloadTextCommand.ExecutionTask.Status}" />
```

### 带参数的命令

#### 同步带参数

```csharp
public class ParameterCommandViewModel : ObservableObject
{
    public ParameterCommandViewModel()
    {
        SelectContactCommand = new RelayCommand<Contact>(SelectContact);
    }

    public ICommand SelectContactCommand { get; }

    private void SelectContact(Contact contact)
    {
        if (contact != null)
        {
            SelectedContact = contact;
        }
    }
}
```

#### 异步带参数

```csharp
public class AsyncParameterCommandViewModel : ObservableObject
{
    public AsyncParameterCommandViewModel()
    {
        DeleteUserCommand = new AsyncRelayCommand<User>(DeleteUserAsync);
    }

    public IAsyncRelayCommand DeleteUserCommand { get; }

    private async Task DeleteUserAsync(User user)
    {
        await _userService.DeleteAsync(user.Id);
        // 更新本地集合
    }
}
```

## 高级特性

### 命令取消支持

```csharp
public class CancelCommandViewModel : ObservableObject
{
    public CancelCommandViewModel()
    {
        LongRunningCommand = new AsyncRelayCommand(
            execute: LongRunningOperationAsync,
            cancel: () => _cts?.Cancel());
    }

    public IAsyncRelayCommand LongRunningCommand { get; }
    private CancellationTokenSource? _cts;

    private async Task LongRunningOperationAsync(CancellationToken token)
    {
        _cts = new CancellationTokenSource();
        // 使用token实现可取消的操作
    }
}
```

### 并发执行控制

```csharp
public class ConcurrentCommandViewModel : ObservableObject
{
    public ConcurrentCommandViewModel()
    {
        // 设置AllowConcurrentExecutions=false防止重复点击
        ProcessDataCommand = new AsyncRelayCommand(
            execute: ProcessDataAsync,
            allowConcurrentExecutions: false);
    }

    public IAsyncRelayCommand ProcessDataCommand { get; }

    private async Task ProcessDataAsync()
    {
        // 处理数据
    }
}
```

### 错误处理

#### Try/Catch方式

```csharp
private async Task LoadDataAsync()
{
    try
    {
        await _dataService.LoadAsync();
    }
    catch (Exception ex)
    {
        // 处理错误
    }
}
```

#### 异常流转到任务调度器

```csharp
[RelayCommand(FlowExceptionsToTaskScheduler = true)]
private async Task LoadContactsAsync()
{
    var contacts = await _service.GetContactsAsync();
    // 异常会被捕获并由任务调度器处理
}
```

## 最佳实践

### 1. 命令命名规范
- 使用动词或动词短语
- 后缀使用"Command"
- 示例：**SaveCommand**, **RefreshDataCommand**

### 2. 性能考虑
- 避免在CanExecute中执行复杂计算
- 使用合理的默认值避免频繁触发CanExecuteChanged

### 3. 内存管理
- 确保取消不必要的异步操作
- 及时清理事件订阅

### 4. 测试建议
```csharp
[Test]
public async Task AsyncCommand_ShouldExecuteProperly()
{
    var viewModel = new TestViewModel();
    
    // 测试命令执行
    await viewModel.TestCommand.ExecuteAsync(null);
    
    // 验证结果
    Assert.IsTrue(viewModel.IsOperationComplete);
}
```

## UI层集成示例

```xml
<ContentPage.Resources>
    <converters:TaskResultConverter x:Key="TaskResultConverter" />
</ContentPage.Resources>

<VerticalStackLayout>
    <Button Text="点击执行"
            Command="{Binding AsyncCommand}" />
    
    <!-- 命令执行状态显示 -->
    <ActivityIndicator IsRunning="{Binding AsyncCommand.IsRunning}"
                       IsVisible="{Binding AsyncCommand.IsRunning}" />
    
    <!-- 结果展示 -->
    <Label Text="{Binding AsyncCommand.ExecutionTask, Converter={StaticResource TaskResultConverter}}"
           IsVisible="{Binding AsyncCommand.ExecutionTask, Converter={StaticResource ResourceNotNull}}" />
    
    <!-- 错误展示 -->
    <Label Text="{Binding AsyncCommand.ErrorMessage}"
           IsVisible="{Binding AsyncCommand.IsFaulted}"
           TextColor="Red" />
</VerticalStackLayout>