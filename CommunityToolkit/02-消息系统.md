# CommunityToolkit.Mvvm 消息系统详解

## 概述

CommunityToolkit.Mvvm 的消息系统（Messenger）实现了松耦合的组件通信，允许不同ViewModel、视图和服务之间进行数据传递而无需直接引用。这种模式解决了MVVM架构中跨组件通信的难题。

## 核心概念

### 消息类型
1. **ValueChangedMessage<T>** - 值变更通知
2. **RequestMessage<TRequest, TResponse>** - 请求-响应模式
3. **PropertyChangedMessage<T>** - 属性变更消息
4. **用户自定义消息** - 继承自消息基类

### 消息接收者
- **ObservableRecipient** - 基础消息接收者
- **ObservableObject** - 通过注册也可以使用
- **IRecipient<TMessage>** - 接口式接收者

## 消息类型详解

### 1. 值变更消息 (ValueChangedMessage)

#### 定义消息
```csharp
// 用户名变更消息
public sealed class UsernameChangedMessage : ValueChangedMessage<string>
{
    public UsernameChangedMessage(string username) : base(username)
    {
    }
}
```

#### 发送消息
```csharp
// 在任何位置发送消息
var message = new UsernameChangedMessage("new_username");
Messenger.Send(message);

// 或者简写
Messenger.Send(new UsernameChangedMessage("new_username"));
```

#### 接收消息
```csharp
// 方法1：在ObservableRecipient中注册
public class UserReceiverViewModel : ObservableRecipient
{
    private string username = "";
    
    public string Username
    {
        get => username;
        private set => SetProperty(ref username, value);
    }

    protected override void OnActivated()
    {
        // 注册消息处理器
        Messenger.Register<UserReceiverViewModel, UsernameChangedMessage>(this, (r, m) => r.Username = m.Value);
    }
}
```

### 2. 请求-响应消息

#### 定义请求消息
```csharp
// 获取当前用户名的请求
public sealed class CurrentUsernameRequestMessage : RequestMessage<string>
{
}
```

#### 发送请求
```csharp
// 发送请求并等待响应
string username = Messenger.Send(new CurrentUsernameRequestMessage());

// 或者使用弱引用发送（不等待响应）
WeakReferenceMessenger.Default.Send<CurrentUsernameRequestMessage>();
```

#### 响应请求
```csharp
// 在接收者中注册响应处理器
protected override void OnActivated()
{
    Messenger.Register<UserSenderViewModel, CurrentUsernameRequestMessage>(this, (r, m) => 
    {
        m.Reply(r.Username); // 响应请求
    });
}
```

### 3. 属性变更消息 (PropertyChangedMessage)

#### 发送属性变更消息
```csharp
// 当属性变更时自动发送消息
[RelayCommand]
private void SendPropertyMessage()
{
    Username = Username == "Bob" ? "Alice" : "Bob";
    
    // 手动发送属性变更消息
    Messenger.Send(new PropertyChangedMessage<string>(this, nameof(Username), Username));
}
```

## 高级用法

### 1. 基于IRecipient接口的接收者

#### 定义接收者
```csharp
public class MyViewModel : ObservableObject, IRecipient<MyMessage>
{
    public MyViewModel()
    {
        // 自动注册
        Messenger.RegisterAll(this);
    }

    public void Receive(MyMessage message)
    {
        // 处理消息
        CurrentMessage = message.Value;
    }
}
```

### 2. 消息过滤

```csharp
protected override void OnActivated()
{
    Messenger.Register<MainViewModel, ErrorMessage>(this, (r, m) =>
    {
        // 只在特定条件下处理消息
        if (m.Severity == MessageSeverity.Critical)
        {
            r.HandleError(m.Message);
        }
    });
}
```

### 3. 消息路由

```csharp
// 发送消息给特定标记的接收者
public sealed class UserMessage : ValueChangedMessage<string>
{
    public string Target { get; }
    
    public UserMessage(string username, string target) : base(username)
    {
        Target = target;
    }
}

// 注册时指定标记
Messenger.Register<AdminViewModel, UserMessage>(this, "admin", (r, m) => 
{
    if (m.Target == "admin")
    {
        // 处理消息
    }
});
```

## 实际使用场景

### 场景1：跨页面通信

#### 发送页面
```csharp
public class ContactEditorViewModel : ObservableObject
{
    [RelayCommand]
    private void SaveContact()
    {
        var contact = new Contact(Name, Email);
        
        // 发送新增联系人消息
        Messenger.Send(new ContactAddedMessage(contact));
    }
}
```

#### 接收页面
```csharp
public class ContactListViewModel : ObservableRecipient
{
    public ObservableCollection<Contact> Contacts { get; } = new();

    protected override void OnActivated()
    {
        // 监听新增联系人消息
        Messenger.Register<ContactListViewModel, ContactAddedMessage>(this, (r, m) =>
        {
            r.Contacts.Add(m.Value);
        });
    }
}
```

### 场景2：全局设置通知

```csharp
// 设置变更消息
public sealed class SettingsChangedMessage<T> : ValueChangedMessage<(string Key, T Value)>
{
    public SettingsChangedMessage(string key, T value) : base((key, value))
    {
    }
}

// 设置服务
public class SettingsService : ObservableRecipient
{
    public void SetSetting<T>(string key, T value)
    {
        // 保存设置
        Preferences.Default.Set(key, value);
        
        // 通知所有监听者
        Messenger.Send(new SettingsChangedMessage<T>(key, value));
    }
}

// 监听设置变化
public class MainViewModel : ObservableRecipient
{
    protected override void OnActivated()
    {
        Messenger.Register<MainViewModel>(this, (r, m) =>
        {
            Messenger.Register<SettingsChangedMessage<string>, SettingsChangedMessage<int>>(this, (r, m) =>
            {
                switch (m.Key)
                {
                    case "theme":
                        // 应用主题
                        break;
                    case "fontSize":
                        // 更新字体
                        break;
                }
            });
        });
    }
}
```

### 场景3：请求-响应模式

```csharp
// API调用请求消息
public sealed class ApiRequestMessage<T> : RequestMessage<T>
{
    public string Endpoint { get; }
    public object? Parameters { get; }
    
    public ApiRequestMessage(string endpoint, object? parameters = null)
    {
        Endpoint = endpoint;
        Parameters = parameters;
    }
}

// API服务
public class ApiService : ObservableRecipient
{
    protected override void OnActivated()
    {
        Messenger.Register<ApiService, ApiRequestMessage<Contact[]>>(this, async (r, m) =>
        {
            var response = await ProcessApiRequest(m);
            m.Reply(response);
        });
    }

    private async Task<Contact[]> ProcessApiRequest(ApiRequestMessage<Contact[]> request)
    {
        // 处理API请求
        return await _httpService.GetAsync<Contact[]>(request.Endpoint);
    }
}

// 使用API服务
public class ContactsViewModel : ObservableObject
{
    [RelayCommand]
    private async Task LoadContacts()
    {
        // 发送请求并等待响应
        var contacts = await Messenger.Send<ApiRequestMessage<Contact[]>>(
            new ApiRequestMessage<Contact[]>("contacts"));
        
        Contacts = new ObservableCollection<Contact>(contacts);
    }
}
```

## 内存管理和最佳实践

### 1. 生命周期管理

```csharp
public class DialogViewModel : ObservableRecipient
{
    public DialogViewModel()
    {
        IsActive = true; // 激活消息接收
    }

    // 窗口关闭时取消注册
    protected override void OnDeactivated()
    {
        Messenger.UnregisterAll(this);
        base.OnDeactivated();
    }
}
```

### 2. 内存泄漏预防

使用Disposable模式：
```csharp
public class MessageHandler : IDisposable
{
    public MessageHandler()
    {
        Messenger.Register<MessageHandler, MyMessage>(this, HandleMessage);
    }

    public void Dispose()
    {
        Messenger.UnregisterAll(this);
    }
}
```

### 3. 弱引用消息

```csharp
// 使用WeakReferenceMessenger避免内存泄漏
public static class MessageManager
{
    public static void Send(string message)
    {
        WeakReferenceMessenger.Default.Send(new GlobalMessage(message));
    }
}
```

## 测试消息系统

### 1. 单元测试

```csharp
[Test]
public void Messenger_ShouldDeliverMessage()
{
    // Arrange
    var receiver = new TestReceiver();
    
    // Act
    Messenger.Send(new TestMessage("test_value"));
    
    // Assert
    Assert.AreEqual("test_value", receiver.ReceivedValue);
}

public class TestReceiver : IRecipient<TestMessage>
{
    public string ReceivedValue { get; private set; }
    
    public void Receive(TestMessage message)
    {
        ReceivedValue = message.Value;
    }
}
```

### 2. 集成测试

```csharp
[Test]
public async Task RequestResponse_WorksCorrectly()
{
    // Arrange
    var service = new RespondingService();
    _messenger.Register<RespondingService, RequestMessage<string>>(service, (r, m) =>
    {
        m.Reply("response");
    });
    
    // Act
    var response = await _messenger.Send<RequestMessage<string>>();
    
    // Assert
    Assert.AreEqual("response", response);
}
```

## 错误处理

### 1. 空值检查

```csharp
[RelayCommand]
private void SendMessage()
{
    if (!string.IsNullOrWhiteSpace(MessageText))
    {
        Messenger.Send(new ChatMessage(MessageText, CurrentUser));
    }
}
```

### 2. 异常处理

```csharp
protected override void OnActivated()
{
    Messenger.Register<MyViewModel, MyMessage>(this, (r, m) =>
    {
        try
        {
            ProcessMessage(m);
        }
        catch (Exception ex)
        {
            // 记录异常
            Logger.LogError(ex, "Error processing message");
        }
    });
}
```

## 性能考虑

1. **避免频繁消息发送**：大批量数据变化使用聚合消息
2. **合理使用弱引用**：避免使用强引用导致内存泄漏
3. **消息粒度适中**：不要太细粒度，也不要太粗粒度
4. **及时清理注册**：视图销毁时取消注册

## 与依赖注入集成

```csharp
// 注册消息处理器
services.AddSingleton<INavigationService, NavigationService>();
services.AddSingleton<IMessenger, WeakReferenceMessenger>(); // 默认使用弱引用
services.AddSingleton<IMessenger>(new StrongReferenceMessenger()); // 需要强引用时使用

// 在ViewModel中注入
public class MainViewModel : ObservableRecipient
{
    public MainViewModel(IMessenger messenger)
    {
        Messenger = messenger;
    }
}