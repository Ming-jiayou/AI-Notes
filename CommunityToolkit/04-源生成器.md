# CommunityToolkit.Mvvm 源生成器详解

## 概述

CommunityToolkit.Mvvm 的源生成器（Source Generator）是一项革命性的功能，它在编译时自动生成样板代码，极大地减少了代码冗余并提高了可维护性。这项功能基于C# 9.0的源代码生成器技术，实现了零样板化的MVVM代码。

## 核心组件

### 1. ICommand 源生成器

#### 使用 [RelayCommand] 属性
最基本的用法：

```csharp
public partial class MyViewModel
{
    [RelayCommand]
    private void Greeting(string name)
    {
        Console.WriteLine($"Hello, {name}");
    }

    [RelayCommand]
    private async Task LoadDataAsync(int userId)
    {
        var data = await _service.LoadDataAsync(userId);
        this.Data = data;
    }
}
```

生成的代码：
```csharp
public partial class MyViewModel
{
    private IRelayCommand? greetingCommand;
    public IRelayCommand GreetingCommand => greetingCommand ??= 
        new RelayCommand<string>(Greeting);

    private IAsyncRelayCommand<int>? loadDataAsyncCommand;
    public IAsyncRelayCommand<int> LoadDataAsyncCommand => loadDataAsyncCommand ??= 
        new AsyncRelayCommand<int>(LoadDataAsync);
}
```

#### 高级配置选项

```csharp
public partial class DataViewModel
{
    [RelayCommand(CanExecute = nameof(CanGreet))]
    private void Greet(string name)
    {
        // 实现
    }

    private bool CanGreet(string? name) => !string.IsNullOrWhiteSpace(name);

    [RelayCommand(AllowConcurrentExecutions = false)]
    private async Task UpdateDataAsync()
    {
        // 防止并发执行
    }

    [RelayCommand(FlowExceptionsToTaskScheduler = true)]
    private async Task ProcessDataAsync()
    {
        // 异常不会崩溃，而是流转到任务调度器
    }
}
```

#### 带属性的异步命令

```csharp
public partial class FileViewModel
{
    [NotifyPropertyChangedRecipients]
    [RelayCommand]
    private async Task LoadFileAsync(IFileInfo fileInfo)
    {
        // 生成包含属性更新的命令
    }

    [NotifyCanExecuteChangedFor(nameof(SaveCommand))]
    [RelayCommand]
    private void ModifyData()
    {
        // 数据修改后自动更新Save命令状态
    }

    [RelayCommand(CanExecute = nameof(CanSave))]
    private void Save()
    {
        // Save逻辑
    }
}
```

### 2. ObservableProperty 源生成器

#### 基础用法

```csharp
public partial class PersonViewModel : ObservableObject
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(FullName))]
    private string? firstName;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(FullName))]
    private string? lastName;

    [ObservableProperty]
    [NotifyDataErrorInfo]
    [Required(ErrorMessage = "邮箱不能为空")]
    [EmailAddress(ErrorMessage = "请输入有效的邮箱地址")]
    private string? email;

    public string FullName => $"{FirstName} {LastName}";
}
```

#### 高级属性生成

```csharp
public partial class ProductViewModel : ObservableObject
{
    // 带有自定义验证的属性
    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(BuyCommand))]
    [NotifyPropertyChangedFor(nameof(DisplayPrice))]
    [AlsoNotifyChangeFor(nameof(FormattedPrice))]
    private decimal price;

    // 生成带有INotifyDataErrorInfo支持的可观察属性
    [ObservableProperty]
    [NotifyDataErrorInfo]
    [Range(1, 9999, ErrorMessage = "库存必须在1-9999之间")]
    private int stockQuantity;

    [ObservableProperty]
    [NotifyDataErrorInfo]
    [CustomValidation(typeof(ProductViewModel), "ValidateDiscount")]
    private decimal discountPercentage;

    public string DisplayPrice => $"${Price:F2}";
    
    public string FormattedPrice => discountPercentage > 0 
        ? $"-{discountPercentage}% ${Price * (1 - discountPercentage/100):F2}" 
        : $"${Price:F2}";

    [RelayCommand]
    private void Buy()
    {
        // 购买逻辑
    }
}
```

### 3. 通知选项详解

#### 依赖属性通知

```csharp
public partial class ShoppingCartViewModel : ObservableObject
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Subtotal))]
    [NotifyPropertyChangedFor(nameof(TaxAmount))]
    [NotifyPropertyChangedFor(nameof(Total))]
    private decimal itemsTotal;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Subtotal))]
    [NotifyPropertyChangedFor(nameof(TaxAmount))]
    [NotifyPropertyChangedFor(nameof(Total))]
    private decimal shippingCost = 5.99m;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(TaxAmount))]
    [NotifyPropertyChangedFor(nameof(Total))]
    private decimal taxRate = 0.08m;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(UpdateCartCommand))]
    private ObservableCollection<CartItem> items = new();

    public decimal Subtotal => ItemsTotal + ShippingCost;
    public decimal TaxAmount => Subtotal * TaxRate;
    public decimal Total => Subtotal + TaxAmount;
}
```

#### 泛型支持

```csharp
public partial class GenericViewModel<T> : ObservableObject where T : class
{
    [ObservableProperty]
    [NotifyPropertyChangedRecipients]
    [NotifyCanExecuteChangedFor(nameof(ProcessCommand))]
    private T? currentItem;

    [ObservableProperty]
    private ObservableCollection<T> items = new();

    [RelayCommand]
    private void Process(T item)
    {
        // 处理单个项目
    }

    [RelayCommand]
    private void ProcessAll()
    {
        // 处理所有项目
    }
}
```

### 4. 组合源生成器

#### INotifyPropertyChanged 接口实现

```csharp
public partial class Person
{
    [ObservableProperty]
    private string name;
}

// 使用方式与INotifyPropertyChanged一致
var person = new Person();
person.PropertyChanged += (s, e) => Console.WriteLine($"Property changed: {e.PropertyName}");
person.Name = "Alice"; // 触发PropertyChanged事件
```

#### ObservableObject 继承

```csharp
// 自动生成继承ObservableObject的类
public partial class ProductDto
{
    [ObservableProperty]
    private int id;

    [ObservableProperty]
    private string name = string.Empty;

    [ObservableProperty]
    private decimal price;
}
```

### 5. 高级配置模式

#### 源生成器选项

```csharp
[assembly: GenerateINotifyPropertyChangedForAnnotation(
    typeof(MyNamespace.Person),
    exclude: new[] { nameof(Person.SSN) })]

[assembly: GenerateRelayCommandForAnnotation(
    typeof(MyNamespace.Service),
    include: new[] { nameof(Service.ProcessDataAsync) })]
```

#### 条件排除

```csharp
public partial class SensitiveViewModel : ObservableObject
{
    [ObservableProperty]
    [NotAutoNotify] // 自定义属性排除自动生成
    private SecureString password;

    [ObservableProperty]
    private bool isLoggedIn;
}
```

## 性能优化特性

### 1. 内存高效性

```csharp
public partial class EfficientViewModel : ObservableObject
{
    // 生成惰性加载的getter
    [ObservableProperty]
    private int _counter;

    // 事件处理优化
    public override void OnPropertyChanged(PropertyChangedEventArgs e) 
    {
        // 基类提供优化的PropertyChanged事件
        base.OnPropertyChanged(e);
    }
}
```

### 2. 字符串插值优化

```csharp
[ObservableProperty]
[NotifyPropertyChangedRecipients]
[NotifyPropertyChangedFor(nameof(DisplayValue))]
private int myValue;

// 生成优化后的属性访问器
public string DisplayValue => $"Value: {MyValue} ({MyValue * 2})";
```

### 3. 批量更新

```csharp
public partial class BatchUpdateViewModel : ObservableObject
{
    [ObservableProperty]
    private int x;

    [ObservableProperty]
    private int y;

    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(Position))]
    private int z;

    public string Position => $"({x}, {y}, {z})";

    [RelayCommand]
    private void UpdateInBatch()
    {
        // 批量子级更新
        int oldX = x;
        int oldY = y;
        int oldZ = z;

        // 手动批处理
        OnPropertyChanging(nameof(Position));
        OnMultiplePropertiesChanged(nameof(X), nameof(Y), nameof(Z));
    }
}
```

## 错误处理

### 1. 编译时验证

源生成器会在编译时检查常见错误：

```csharp
// ❌ 错误：缺少partial关键字
public class MyViewModel : ObservableObject
{
    [ObservableProperty]
    private string name; // 编译错误：需要partial关键字
}

// ❌ 错误：循环依赖
public partial class MyViewModel : ObservableObject
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(X))]
    private int x;
}

// ❌ 错误：依赖未定义的属性
public partial class MyViewModel : ObservableObject
{
    [ObservableProperty]
    [NotifyPropertyChangedFor(nameof(NonExistentProperty))]
    private int count;
}
```

### 2. 警告和诊断

```csharp
// 会产生CS0109警告：隐藏继承成员
public partial class DerivedViewModel : BaseViewModel
{
    [ObservableProperty]
    private string name; // 如果BaseViewModel有Name属性
}
```

## 与依赖注入集成

### 1. 构造函数注入

```csharp
public partial class ServiceViewModel : ObservableObject
{
    public ServiceViewModel(IDialogService dialogService)
    {
        DialogService = dialogService;
    }

    [ObservableProperty] 
    private readonly IDialogService dialogService;

    [RelayCommand]
    private async Task ShowMessageAsync(string message)
    {
        await this.DialogService.ShowMessageAsync(message);
    }
}
```

### 2. 服务定位器模式

```csharp
public partial class ViewModelFactory : ObservableObject
{
    [ObservableProperty]
    private string? currentView;

    [RelayCommand]
    private void ChangeView(string viewName)
    {
        CurrentView = viewName;
        // 触发视图创建
    }
}
```

## 高级场景处理

### 1. 基类扩展

```csharp
public abstract partial class BaseViewModel : ObservableObject
{
    [ObservableProperty]
    private bool isBusy;

    [ObservableProperty]
    private string? error;

    [ObservableProperty]
    [NotifyCanExecuteChangedFor(nameof(SaveCommand))]
    [NotifyCanExecuteChangedFor(nameof(CancelCommand))]
    protected FormState formState;
}

public partial class PersonViewModel : BaseViewModel
{
    [ObservableProperty]
    private string name;

    [ObservableProperty]
    private int age;
}
```

### 2. 多态属性

```csharp
public partial class AnimalViewModel : ObservableObject
{
    [ObservableProperty]
    private string species;

    public virtual string DisplayName => $"Animal: {Species}";
}

public partial class CatViewModel : AnimalViewModel
{
    [ObservableProperty]
    private string breed;

    public override string DisplayName => $"{base.DisplayName} ({Breed})";
}
```

## 调试和故障排除

### 1. 查看生成的代码

```csharp
// 项目文件配置
<ItemGroup>
    <CompilerVisibleProperty Include="CommunityToolkit_Mvvm_SourceGenerators_EnableNotNullAnnotations" />
    <CompilerVisibleProperty Include="CommunityToolkit_Mvvm_SourceGenerators_SuppressOrphanedPropertyChangeTokens" />
</ItemGroup>
```

### 2. 调试生成的属性

```csharp
public partial class DebugViewModel : ObservableObject
{
    [ObservableProperty]
    [AlsoBroadcastChange] // 调试时使用广播
    private string currentValue;

    partial void OnCurrentValueChanged(string value)
    {
        // 生成的部分方法
        Console.WriteLine($"Current value changed to: {value}");
    }

    // 检查生成的属性
    public void DebugProperty()
    {
        var type = this.GetType();
        var property = type.GetProperty("CurrentValue");
        Console.WriteLine($"Property type: {property?.PropertyType}");
    }
}
```

## 性能测试和基准

```csharp
// 性能测试类
[MemoryDiagnoser]
public class PropertyTests
{
    [Benchmark(Baseline = true)]
    public void ManualProperty()
    {
        var vm = new ManualViewModel();
        vm.Name = "Test";
    }

    [Benchmark]
    public void GeneratedProperty()
    {
        var vm = new GeneratedViewModel();
        vm.Name = "Test";
    }
}

// 手动实现
class ManualViewModel : INotifyPropertyChanged
{
    private string? name;
    public string? Name
    {
        get => name;
        set
        {
            if (name != value)
            {
                name = value;
                OnPropertyChanged(nameof(Name));
            }
        }
    }

    public event PropertyChangedEventHandler? PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName) => 
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}

// 生成实现
public partial class GeneratedViewModel : ObservableObject
{
    [ObservableProperty]
    private string? name;
}
```

这个源生器系统极大地简化了MVVM代码的编写，同时保持了高性能和类型安全。