# CommunityToolkit.Mvvm 数据验证详解

## 概述

CommunityToolkit.Mvvm 提供了强大的数据验证支持，使得表单验证变得简单而直观。通过继承 `ObservableValidator` 类并使用数据注解，可以轻松实现复杂的验证逻辑。

## 基础验证

### 1. ObservableValidator 基础

#### 创建验证视图模型

```csharp
using CommunityToolkit.Mvvm.ComponentModel;
using System.ComponentModel.DataAnnotations;

public partial class LoginViewModel : ObservableValidator
{
    [ObservableProperty]
    [Required(ErrorMessage = "用户名不能为空")]
    [MinLength(3, ErrorMessage = "用户名至少3个字符")]
    [MaxLength(20, ErrorMessage = "用户名最多20个字符")]
    private string? username;

    [ObservableProperty]
    [Required(ErrorMessage = "密码不能为空")]
    [MinLength(6, ErrorMessage = "密码至少需要6个字符")]
    [RegularExpression(@"^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).+$", 
        ErrorMessage = "密码必须包含大小写字母和数字")]
    private string? password;

    [RelayCommand]
    private void Login()
    {
        ValidateAllProperties();
        
        if (!HasErrors)
        {
            // 执行登录逻辑
            PerformLogin(Username!, Password!);
        }
    }
}
```

### 2. 标准验证属性

以下是常用的数据注解验证属性：

#### 基本验证

```csharp
public partial class UserValidator : ObservableValidator
{
    // 必填字段验证
    [ObservableProperty]
    [Required(ErrorMessage = "姓名为必填项")]
    private string? name;

    // 字符串长度验证
    [ObservableProperty]
    [StringLength(100, MinimumLength = 2, 
        ErrorMessage = "姓名必须在2-100个字符之间")]
    private string? fullName;

    // 数值范围验证
    [ObservableProperty]
    [Range(18, 100, ErrorMessage = "年龄必须在18-100岁之间")]
    private int age;

    // 正则表达式验证
    [ObservableProperty]
    [RegularExpression(@"^[\w\.\-]+@[\w\-]+(\.[\w\-]+)+$", 
        ErrorMessage = "请输入有效的邮箱地址")]
    private string? email;

    // 电话验证
    [ObservableProperty]
    [Phone(ErrorMessage = "请输入有效的电话号码")]
    private string? phone;

    // URL验证
    [ObservableProperty]
    [Url(ErrorMessage = "请输入有效的网址")]
    private string? website;

    // 信用卡验证
    [ObservableProperty]
    [CreditCard(ErrorMessage = "请输入有效的信用卡号")]
    private string? creditCard;

    // 自定义比较验证
    [ObservableProperty]
    [Compare(nameof(Password), ErrorMessage = "两次输入的密码不一致")]
    private string? confirmPassword;
}
```

#### 复合验证

```csharp
[ObservableProperty]
[Required(ErrorMessage = "日期不能为空")]
[CustomValidation(typeof(MyCustomValidators), "ValidateBirthDate")]
private DateTime? birthDate;

[ObservableProperty]
[Required(ErrorMessage = "开始日期不能为空")]
[CustomValidation(typeof(MyCustomValidators), "ValidateStartDate")]
private DateTime? startDate;

[ObservableProperty]
[Required(ErrorMessage = "结束日期不能为空")]
[CustomValidation(typeof(MyCustomValidators), "ValidateEndDateRange")]
private DateTime? endDate;

public static class MyCustomValidators
{
    public static ValidationResult? ValidateBirthDate(DateTime? date, ValidationContext context)
    {
        if (date.HasValue && date.Value > DateTime.Now.AddYears(-18))
        {
            return new ValidationResult("必须满18周岁");
        }
        return ValidationResult.Success;
    }

    public static ValidationResult? ValidateEndDateRange(DateTime? endDate, ValidationContext context)
    {
        var instance = (UserValidator)context.ObjectInstance;
        if (endDate.HasValue && instance.StartDate.HasValue && endDate.Value <= instance.StartDate.Value)
        {
            return new ValidationResult("结束日期必须大于开始日期");
        }
        return ValidationResult.Success;
    }
}
```

## 复杂验证场景

### 1. 集合验证

```csharp
public partial class ProductValidator : ObservableValidator
{
    [ObservableProperty]
    [Required]
    [MinLength(1, ErrorMessage = "至少需要选择一项")]
    [ValidateEnumeration]
    private List<string> categories = new();

    [ObservableProperty]
    [Required]
    [MinCount(1, ErrorMessage = "至少需要添加一个商品")]
    [ValidateChild]
    private ObservableCollection<ProductItem> items = new();
}

public class ProductItem
{
    [Required(ErrorMessage = "商品名称不能为空")]
    public string Name { get; set; } = string.Empty;

    [Range(0.01, 10000.00, ErrorMessage = "价格必须在0.01-10000之间")]
    public decimal Price { get; set; }

    [Range(1, 100, ErrorMessage = "数量必须在1-100之间")]
    public int Quantity { get; set; }
}
```

### 2. 动态验证规则

```csharp
public partial class FormValidator : ObservableValidator
{
    [ObservableProperty]
    private string? country;

    [ObservableProperty]
    [Required(ErrorMessage = "证件号不能为空")]
    [RegularExpression(@"^\d{11}$", ErrorMessage = "请输入11位身份证号")]
    private string? idNumber;

    // 根据国家动态变更验证规则
    partial void OnCountryChanged(string? value)
    {
        // 清除现有的验证规则
        ClearErrors(nameof(IdNumber));

        // 根据国家设置新的验证规则
        if (value == "USA")
        {
            // 美国SSN格式
            AddValidationRule(nameof(IdNumber), 
                new RegularExpressionAttribute(@"^\d{3}-\d{2}-\d{4}$")
                {
                    ErrorMessage = "请输入有效的SSN格式"
                });
        }
        else if (value == "CN")
        {
            // 中国身份证号格式
            AddValidationRule(nameof(IdNumber), 
                new RegularExpressionAttribute(@"^\d{18}|^\d{17}[Xx]$")
                {
                    ErrorMessage = "请输入18位身份证号"
                });
        }

        // 重新验证
        ValidateProperty(IdNumber, nameof(IdNumber));
    }
}
```

### 3. 异步验证

```csharp
public partial class UniqueUsernameValidator : ObservableValidator
{
    private readonly IUserService _userService;

    public UniqueUsernameValidator(IUserService userService)
    {
        _userService = userService;
    }

    [ObservableProperty]
    [Required(ErrorMessage = "用户名不能为空")]
    [StringLength(20, MinimumLength = 3)]
    [CustomValidation(typeof(UniqueUsernameValidator), "ValidateUsernameAsync")]
    private string? username;

    public static async Task<ValidationResult?> ValidateUsernameAsync(string? username, 
        ValidationContext context)
    {
        if (string.IsNullOrWhiteSpace(username))
        {
            return ValidationResult.Success;
        }

        var validator = (UniqueUsernameValidator)context.ObjectInstance;
        var exists = await validator._userService.IsUsernameExistsAsync(username);
        
        if (exists)
        {
            return new ValidationResult("用户名已存在");
        }
        
        return ValidationResult.Success;
    }
}
```

## 错误显示和处理

### 1. 显示验证错误

```xaml
<ContentPage xmlns:converters="clr-namespace:CommunityToolkit.Maui.Converters">
    <ContentPage.Resources>
        <converters:IsNotNullOrEmptyConverter x:Key="IsNotNullOrEmpty"/>
    </ContentPage.Resources>
    
    <VerticalStackLayout>
        <Entry Text="{Binding Email}">
            <Entry.Behaviors>
                <converters:EntryValidationBehavior
                    MaximumLength="100"
                    IsValid="{Binding GetErrors('Email'), Converter={StaticResource IsNotNullOrEmpty}, ConverterParameter='Inverse'}" />
            </Entry.Behaviors>
        </Entry>

        <Label Text="{Binding GetErrors('Email')[0]}" 
               TextColor="Red"
               IsVisible="{Binding HasErrors}">
            <Label.Triggers>
                <DataTrigger.EnterActions>
                    <DataTrigger.Binding>
                        <Binding Path="GetErrors('Email').Count" 
                                 Converter="{StaticResource GreaterThanZeroConverter}"/>
                    </DataTrigger.Binding>
                    <BeginStoryboard>
                        <Storyboard>
                            <DoubleAnimation Storyboard.TargetProperty="Opacity" 
                                           From="0" To="1" Duration="0:0:0.2"/>
                        </Storyboard>
                    </BeginStoryboard>
                </DataTrigger.EnterActions>
            </Label.Triggers>
        </Label>
    </VerticalStackLayout>
</ContentPage>
```

### 2. 命令式验证

```csharp
public partial class FormValidator : ObservableValidator
{
    [RelayCommand]
    private async Task SubmitFormAsync()
    {
        // 验证所有属性
        ValidateAllProperties();

        if (HasErrors)
        {
            // 显示第一个错误
            var firstError = GetErrors().First();
            await _dialogService.ShowMessageAsync("验证失败", firstError.ErrorMessage!);
            return;
        }

        // 提交数据
        await SubmitDataAsync();
    }

    [RelayCommand]
    private void ResetForm()
    {
        // 重置所有属性和验证状态
        this.Username = null;
        this.Email = null;
        
        // 清除所有验证错误
        ClearAllErrors();
    }
}
```

## 自定义验证属性

### 1. 创建验证属性

```csharp
public class CreditCardNumberAttribute : ValidationAttribute
{
    public CreditCardNumberAttribute()
    {
        ErrorMessage = "请输入有效的信用卡号";
    }

    protected override ValidationResult? IsValid(object? value, ValidationContext context)
    {
        if (value == null)
            return ValidationResult.Success;

        var cardNumber = value.ToString()?.Replace("-", "").Replace(" ", "");
        
        if (string.IsNullOrWhiteSpace(cardNumber))
            return new ValidationResult(!string.IsNullOrEmpty(ErrorMessage) ? 
                ErrorMessage : "信用卡号不能为空");

        // Luhn算法验证
        if (!IsValidLuhn(cardNumber))
            return new ValidationResult("无效的信用卡号格式");

        return ValidationResult.Success;
    }

    private bool IsValidLuhn(string cardNumber)
    {
        int sum = 0;
        bool alternate = false;
        
        for (int i = cardNumber.Length - 1; i >= 0; i--)
        {
            if (!int.TryParse(cardNumber[i].ToString(), out int digit))
                return false;

            if (alternate)
            {
                digit *= 2;
                if (digit > 9)
                    digit -= 9;
            }
            sum += digit;
            alternate = !alternate;
        }
        return sum % 10 == 0;
    }
}
```

### 2. 使用自定义验证

```csharp
[ObservableProperty]
[Required(ErrorMessage = "信用卡号不能为空")]
[CreditCardNumber]
private string? creditCardNumber;
```

## 验证策略

### 1. 分步验证

```csharp
public partial class MultiStepFormValidator : ObservableValidator
{
    public enum ValidationStep
    {
        PersonalInfo,
        ContactInfo,
        AccountInfo
    }

    [ObservableProperty]
    private ValidationStep currentStep = ValidationStep.PersonalInfo;

    [ObservableProperty]
    [RequiredWhenStep(ValidationStep.PersonalInfo, ErrorMessage = "请填写姓名")]
    private string? fullName;

    [ObservableProperty]
    [RequiredWhenStep(ValidationStep.ContactInfo, ErrorMessage = "请填写邮箱")]
    [EmailAddress]
    private string? email;

    [ObservableProperty]
    [RequiredWhenStep(ValidationStep.AccountInfo, ErrorMessage = "请设置密码")]
    private string? password;

    [RelayCommand]
    private void GoToNextStep()
    {
        switch (CurrentStep)
        {
            case ValidationStep.PersonalInfo:
                if (ValidatePersonalInfo())
                    CurrentStep = ValidationStep.ContactInfo;
                break;
            case ValidationStep.ContactInfo:
                if (ValidateContactInfo())
                    CurrentStep = ValidationStep.AccountInfo;
                break;
            case ValidationStep.AccountInfo:
                if (ValidateAccountInfo())
                    SubmitForm();
                break;
        }
    }

    private bool ValidatePersonalInfo()
    {
        var result = new List<ValidationResult>();
        Validator.TryValidateProperty(FullName, 
            new ValidationContext(this, serviceProvider: null, items: null) 
            { MemberName = nameof(FullName) }, result);
        return !result.Any();
    }
}
```

### 2. 条件验证

```csharp
public partial class ConditionalValidator : ObservableValidator
{
    [ObservableProperty]
    private bool isCompany;

    [ObservableProperty]
    [RequiredIf("IsCompany", true, ErrorMessage = "公司名称必填")]
    private string? companyName;

    [ObservableProperty]
    [RequiredIf("IsCompany", true, ErrorMessage = "税号必填")]
    [RegularExpression(@"^\d{15,20}$")]
    private string? taxNumber;

    [ObservableProperty]
    [RequiredIf("IsCompany", false, ErrorMessage = "个人姓名必填")]
    private string? personalName;
}

public class RequiredIfAttribute : ValidationAttribute
{
    private readonly string _propertyName;
    private readonly object _desiredValue;

    public RequiredIfAttribute(string propertyName, object desiredValue)
    {
        _propertyName = propertyName;
        _desiredValue = desiredValue;
    }

    protected override ValidationResult? IsValid(object? value, ValidationContext context)
    {
        var instance = context.ObjectInstance;
        var type = instance.GetType();
        var property = type.GetProperty(_propertyName);
        
        if (property != null)
        {
            var actualValue = property.GetValue(instance);
            if (Equals(actualValue, _desiredValue))
            {
                if (value == null || string.IsNullOrWhiteSpace(value.ToString()))
                {
                    return new ValidationResult(!string.IsNullOrEmpty(ErrorMessage) ? 
                        ErrorMessage : $"{context.DisplayName}为必填项");
                }
            }
        }
        
        return ValidationResult.Success;
    }
}
```

## 与UI集成

### 1. 实时验证

```csharp
public partial class RealTimeValidator : ObservableValidator
{
    public RealTimeValidator()
    {
        // 属性变化时自动验证
        PropertyChanged += (sender, args) =>
        {
            if (args.PropertyName is not null)
            {
                ValidateProperty(this[args.PropertyName], args.PropertyName);
            }
        };
    }
}
```

### 2. 错误摘要

```csharp
public partial class FormValidator : ObservableValidator
{
    public string ErrorCollectionSummary => 
        string.Join(Environment.NewLine, 
            GetErrors().Select(e => $"• {e.MemberNames.FirstOrDefault()}: {e.ErrorMessage}"));

    public bool HasRequiredErrors => GetErrors().Any(e => e.ErrorMessage?.Contains("必填") == true);
    public bool HasFormatErrors => GetErrors().Any(e => e.ErrorMessage?.Contains("格式") == true);
}
```

这个验证系统提供了企业级的数据验证解决方案，支持复杂业务场景下的各种验证需求。