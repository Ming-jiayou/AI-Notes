# DependencyProperty 源码深度阅读笔记  
> 基于 .NET WPF `WindowsBase.dll` 内 `System.Windows.DependencyProperty`（完整源码逐行阅读）

---

## 一、定位与职责

`DependencyProperty` 是 **WPF 依赖属性系统的注册中心**  
位置： `WindowsBase.dll → System.Windows.DependencyProperty`  
功能一句话：  
> 把“字段值”抽象成“可被外部驱动的符号”，并集中管理这些符号及元数据。

---

## 二、核心静态字段速览

| 字段 | 作用 |
|---|---|
| `PropertyFromName` | `Dictionary<FromNameKey, DependencyProperty>`  全局“名字→属性”映射 |
| `RegisteredPropertyList` | `ItemStructList<DependencyProperty>`  所有已注册实例的顺序列表（可 O(1) 索引） |
| `GlobalIndexCount` | 自增计数器 → 给每个新 DP 一个唯一 GlobalIndex |
| `UnsetValue` | 只读静态单例，标记“尚未赋值” |

---

## 三、构造函数与字段

私有化构造（*1050-1087*），由注册方法统一调用：

```csharp
private DependencyProperty(
        string name,
        Type propertyType,
        Type ownerType,
        PropertyMetadata defaultMetadata,
        ValidateValueCallback validateValueCallback)
```

主要只读实例字段：

- `_name`, `_propertyType`, `_ownerType`, `_defaultMetadata`, `_validateValueCallback`
- `_readOnlyKey`: 若为只读属性，保存 `DependencyPropertyKey` 以做校验
- `_packedData`: 位域（`Flags`）保存大量布尔状态
- `_metadataMap`: 保存“**继承层次**上各派生类的专属元数据” （后面详述）

---

## 四、公共注册 API

### 4.1 普通依赖属性

| 方法签名（简化） | 说明 |
|---|---|
| `Register(string, Type, Type)` | 最简重载，内部转发 |
| `Register(..., PropertyMetadata)` | 可附带默认元数据 |
| `Register(..., PropertyMetadata, ValidateValueCallback)` | 完全形态 |

内部全部收敛到：

```csharp
RegisterCommon(string name, Type propertyType, Type ownerType,
               PropertyMetadata defaultMetadata,
               ValidateValueCallback validateValueCallback)
```

- 先参数校验
- 创建唯一 `FromNameKey(Name, OwnerType)` → 防止重复注册
- 自动为未赋值元数据调用 `AutoGeneratePropertyMetadata`
- 在 `PropertyFromName` 中加入映射并返回实例

### 4.2 只读属性

| 方法签名 | 说明 |
|---|---|
| `RegisterReadOnly`  | 非附加/附加都有重载 |
| `RegisterAttachedReadOnly` |

- 返回 `DependencyPropertyKey`，调用者必须通过该 Key 才能 `SetValue`
- 构造函数时即把 `_readOnlyKey` 指针写入 DP，**fail-secure 设计**（注释原文）

### 4.3 附加属性

`RegisterAttached` 系列，**功能与普通注册完全一致**，仅语义区分（附加属性常见于 `Grid.Row="1"` 这类语法）。

---

## 五、元数据覆盖 `OverrideMetadata`

场景：基类定义 DP，派生类希望**保留 key 不变**但更改默认值、回调等。

```csharp
public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata)
public void OverrideMetadata(Type forType, PropertyMetadata typeMetadata,
                             DependencyPropertyKey key)
```

流程（`SetupOverrideMetadata` + `ProcessOverrideMetadata`）：

1. 确保 `forType` 派生自 `DependencyObject`
2. **强制**所有父类先跑完静态构造函数（加载其父元数据）
3. 将新元数据插入 `_metadataMap[DependencyObjectType.Id]`  
   - 采用稀疏 ID 映射 → **O(1) 查找**
4. 调用 `typeMetadata.Seal` 保证不可再改
5. 位域更新：
   - `IsPotentiallyInherited`  
   - `IsDefaultValueChanged`  
   - `IsPotentiallyUsingDefaultValueFactory`

---

## 六、查找与索引

### 6.1 FromName

```csharp
internal static DependencyProperty FromName(string name, Type ownerType)
```

- 同时遍历继承链： `ownerType → BaseType... → null`
- 对每个 Type 先跑静态构造器（防止懒加载遗漏 DP）
- lock 内访问 `PropertyFromName`

### 6.2 GlobalIndex

- 由 `GetUniqueGlobalIndex` 在构造函数内部产生，保证全局唯一
- `Flags` 位域低 16 位保存索引，剩余位存布尔特征

---

## 七、元数据检索

`public PropertyMetadata GetMetadata(Type/DependencyObject/DependencyObjectType)` 三重重载，内部调用：

```csharp
internal PropertyMetadata GetMetadata(DependencyObjectType dType)
```

算法亮点：

> **父类向上回溯** + **稀疏索引** 双策略  
> 先用 `_metadataMap` 查是否有“精确覆盖”，若无则用 base 元数据链条回溯，最上层回退到 `_defaultMetadata`。

时间复杂度：  
- 若有覆盖：**O(1)**  
- “缺失”情况回溯 ≤ 类型链深度，**O(depth)**

---

## 八、内部辅助

- `AutoGenerateDefaultValue(type)`：值类型 `Activator.CreateInstance`，引用类型 `null`
- `ValidateMetadataDefaultValue` / `ValidateDefaultValueCommon`：保证默认值合法、线程无 Affinity、不与 ValidateCallback 冲突
- `DesignerCoerceValueCallback`：设计器专用回退

---

## 九、并发模型

全局使用 `static readonly Lock Synchronized`：

- **写操作**（注册/Override）全程加锁  
- **读操作**（GetMetadata/FromName）通过：

  - **lock-free** 的 `_metadataMap` 只读遍历  
  - 对 `PropertyFromName` 只在 lock 内访问

> 对读友好，满足 WPF 高频率读取、低频率注册的场景。

---

## 十、设计精髓

1. **把字段“符号化”**：  
   运行时通过 `GlobalIndex` 定位到 DP 对象 → 解耦声明与存储
2. **元数据可继承**：  
   DefaultMetadata 统一基类默认值，派生类通过 `_metadataMap` 无损覆盖
3. **静态注册 + 全局字典** 实现**单例**与**反射级发现**
4. **强类型约束**：  
   编译器不会管，运行时层层校验（`IsValidType`, `ValidateValueCallback`, 线程 affinity 检查）
5. **Fail-Fast & Secure**：  
   只读、默认值及 Validate 异常全部在注册/Override 阶段抛出，拒绝非法配置

---

## 十一、简单使用示例

```csharp
public class MyControl : Control
{
    // 注册
    public static readonly DependencyProperty FooProperty =
        DependencyProperty.Register(
            "Foo",
            typeof(int),
            typeof(MyControl),
            new PropertyMetadata(0, OnFooChanged));

    public int Foo
    {
        get => (int)GetValue(FooProperty);
        set => SetValue(FooProperty, value);
    }

    private static void OnFooChanged(DependencyObject d,
                                     DependencyPropertyChangedEventArgs e)
    {
        // 响应变化
    }
}
```

---

## 十二、结论

`DependencyProperty` 把传统 **CLR 字段** 提升为 **可继承、可动画、可绑定、可验证、可元数据覆盖的通用属性描述符**。  
借助静态注册表 + 元数据映射的双重索引，保证了：

- **查找高效**  
- **继承透明**  
- **线程安全**

为 WPF 整个依赖体系（Style、Binding、Animation、Value Store）打下底层地基。